#!/usr/bin/env bash
set -euo pipefail

APP_DIR="/opt/xui-sync-agent"
ETC_DIR="/etc/xui-sync-agent"
VAR_DIR="/var/lib/xui-sync-agent"
BIN="/usr/local/bin/xui-sync-agent"
CONF="$ETC_DIR/config.json"
KEY="$ETC_DIR/id_ed25519"
PY="$APP_DIR/agent.py"

SERVICE_NAME="xui-sync-agent"
SERVICE_FILE="/etc/systemd/system/${SERVICE_NAME}.service"
TIMER_FILE="/etc/systemd/system/${SERVICE_NAME}.timer"

color() { local c="$1"; shift; printf "\033[%sm%s\033[0m\n" "$c" "$*"; }
info(){ color "36" "[i] $*"; }
ok(){ color "32" "[OK] $*"; }
warn(){ color "33" "[!] $*"; }
err(){ color "31" "[X] $*"; }

need_root() {
  if [[ "${EUID:-$(id -u)}" -ne 0 ]]; then
    err "این اسکریپت باید با root اجرا بشه."
    exit 1
  fi
}

install_deps() {
  info "Installing dependencies..."
  apt-get update -y >/dev/null
  DEBIAN_FRONTEND=noninteractive apt-get install -y python3 sqlite3 openssh-client >/dev/null
  ok "Dependencies installed."
}

detect_local_db() {
  local candidates=(
    "/etc/x-ui/x-ui.db"
    "/usr/local/x-ui/x-ui.db"
    "/var/lib/x-ui/x-ui.db"
    "/opt/x-ui/x-ui.db"
  )
  for p in "${candidates[@]}"; do
    if [[ -f "$p" ]]; then
      echo "$p"; return 0
    fi
  done
  echo ""
}

detect_local_service() {
  # try common names
  local candidates=("x-ui" "xui" "3x-ui" "xray-ui")
  for s in "${candidates[@]}"; do
    if systemctl list-unit-files --no-pager 2>/dev/null | awk '{print $1}' | grep -qx "${s}.service"; then
      echo "$s"; return 0
    fi
  done
  # fallback: search any service with x-ui in name
  local found
  found="$(systemctl list-unit-files --no-pager 2>/dev/null | awk '{print $1}' | grep -E 'x-?ui|3x-?ui' | head -n1 || true)"
  if [[ -n "$found" ]]; then
    echo "${found%.service}"; return 0
  fi
  echo ""
}

write_python_agent() {
  mkdir -p "$APP_DIR" "$ETC_DIR" "$VAR_DIR"
  cat >"$PY" <<'PY'
#!/usr/bin/env python3
import json, os, sys, time, socket, subprocess, sqlite3, tempfile

CONF = "/etc/xui-sync-agent/config.json"

def sh(cmd:list[str], check=True, input_text=None, timeout=60):
    p = subprocess.run(cmd, input=input_text, text=True,
                       stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=timeout)
    if check and p.returncode != 0:
        raise RuntimeError(f"CMD failed: {' '.join(cmd)}\nSTDERR:\n{p.stderr.strip()}")
    return p

def load_conf():
    with open(CONF, "r", encoding="utf-8") as f:
        return json.load(f)

def detect_hostname():
    return socket.gethostname() or "unknown"

def local_rows(db_path):
    con = sqlite3.connect(db_path, timeout=5)
    con.row_factory = sqlite3.Row
    cur = con.cursor()
    cur.execute("SELECT email, up, down, expiry_time, total, enable FROM client_traffics;")
    rows = []
    for r in cur.fetchall():
        rows.append({
            "email": r["email"],
            "up": int(r["up"] or 0),
            "down": int(r["down"] or 0),
            "expiry_time": int(r["expiry_time"] or 0),
            "total": int(r["total"] or 0),
            "enable": int(r["enable"] or 0),
        })
    con.close()
    return rows

def sqlite_apply_with_retry(db_path, sql_script, busy_ms=5000, tries=6, sleep_s=1.0):
    last_err = None
    for i in range(tries):
        try:
            con = sqlite3.connect(db_path, timeout=busy_ms/1000)
            cur = con.cursor()
            cur.execute(f"PRAGMA busy_timeout={busy_ms};")
            cur.executescript(sql_script)
            con.commit()
            con.close()
            return True
        except Exception as e:
            last_err = e
            msg = str(e).lower()
            if "locked" in msg or "busy" in msg:
                time.sleep(sleep_s)
                continue
            raise
    raise last_err

def apply_snapshot_local(db_path, snapshot, stop_start_fallback, service_name):
    # Update existing rows only (by email).
    # Writes are done in one transaction.
    sql_lines = [
        "PRAGMA busy_timeout=5000;",
        "BEGIN;"
    ]
    for r in snapshot:
        email = r["email"].replace("'", "''")
        sql_lines.append(
            "UPDATE client_traffics SET "
            f"up={int(r['up'])}, down={int(r['down'])}, expiry_time={int(r['expiry_time'])}, "
            f"total={int(r['total'])}, enable={int(r['enable'])} "
            f"WHERE email='{email}';"
        )
    sql_lines.append("COMMIT;")
    sql = "\n".join(sql_lines) + "\n"

    try:
        sqlite_apply_with_retry(db_path, sql, tries=8, sleep_s=0.6)
        return "ok_no_restart"
    except Exception as e:
        msg = str(e).lower()
        if ("locked" in msg or "busy" in msg) and stop_start_fallback and service_name:
            # last resort
            sh(["systemctl", "stop", service_name], check=False)
            try:
                sqlite_apply_with_retry(db_path, sql, tries=10, sleep_s=0.4)
                return "ok_with_restart"
            finally:
                sh(["systemctl", "start", service_name], check=False)
        raise

def ssh_master(conf, payload_json: str) -> list[dict]:
    # We run a small python "server" on master via SSH.
    # Master keeps state file to avoid double-counting (per agent_id/email).
    master = conf["master"]
    key = conf["ssh_key"]
    agent_id = conf["agent_id"]
    master_db = master.get("db_path") or "/etc/x-ui/x-ui.db"
    master_service = master.get("service_name") or "x-ui"
    allow_restart = "1" if conf.get("allow_master_restart_on_lock", True) else "0"

    remote = r"""
set -euo pipefail
python3 - <<'PY'
import json, os, sys, time, sqlite3, fcntl

AGENT_ID = os.environ.get("AGENT_ID","unknown")
MASTER_DB = os.environ.get("MASTER_DB","/etc/x-ui/x-ui.db")
STATE_DIR = "/var/lib/xui-sync"
STATE_FILE = os.path.join(STATE_DIR, "master_state.json")
LOCK_FILE  = os.path.join(STATE_DIR, "lock")
MASTER_SERVICE = os.environ.get("MASTER_SERVICE","x-ui")
ALLOW_RESTART = os.environ.get("ALLOW_RESTART","1") == "1"

os.makedirs(STATE_DIR, exist_ok=True)

def stop_start_if_needed():
    # minimal and last resort (only if locked)
    os.system(f"systemctl stop {MASTER_SERVICE} >/dev/null 2>&1 || true")
    return

def start_back():
    os.system(f"systemctl start {MASTER_SERVICE} >/dev/null 2>&1 || true")

def load_state():
    if not os.path.exists(STATE_FILE):
        return {}
    with open(STATE_FILE,"r",encoding="utf-8") as f:
        return json.load(f)

def save_state(state):
    tmp = STATE_FILE + ".tmp"
    with open(tmp,"w",encoding="utf-8") as f:
        json.dump(state,f,ensure_ascii=False)
    os.replace(tmp, STATE_FILE)

def db_connect():
    con = sqlite3.connect(MASTER_DB, timeout=5)
    cur = con.cursor()
    cur.execute("PRAGMA busy_timeout=5000;")
    return con, cur

def get_master_snapshot(cur):
    cur.execute("SELECT email, up, down, expiry_time, total, enable FROM client_traffics;")
    out=[]
    for (email, up, down, expiry, total, enable) in cur.fetchall():
        out.append({
            "email": email,
            "up": int(up or 0),
            "down": int(down or 0),
            "expiry_time": int(expiry or 0),
            "total": int(total or 0),
            "enable": int(enable or 0),
        })
    return out

payload = sys.stdin.read()
rows = json.loads(payload) if payload.strip() else []

# lock to serialize updates from multiple agents
with open(LOCK_FILE, "w") as lf:
    fcntl.flock(lf, fcntl.LOCK_EX)

    state = load_state()
    agent_state = state.get(AGENT_ID, {})  # email -> {"up":..,"down":..}

    # apply deltas into master db
    last_err=None
    for attempt in range(1, 9):
        try:
            con, cur = db_connect()
            cur.execute("BEGIN;")
            # update loop
            for r in rows:
                email = r["email"]
                up = int(r.get("up",0))
                down = int(r.get("down",0))
                exp = int(r.get("expiry_time",0))
                total = int(r.get("total",0))
                enable = int(r.get("enable",0))

                prev = agent_state.get(email, {"up": 0, "down": 0})
                du = up - int(prev.get("up",0))
                dd = down - int(prev.get("down",0))
                if du < 0: du = 0
                if dd < 0: dd = 0

                # Traffic: add deltas to master
                if du or dd:
                    cur.execute(
                        "UPDATE client_traffics SET up=up+?, down=down+? WHERE email=?;",
                        (du, dd, email)
                    )

                # Non-traffic fields:
                # expiry_time: take MAX to avoid accidental shortening
                # total: take MAX
                # enable: take MIN (if any panel disables -> disable everywhere)
                if exp:
                    cur.execute("UPDATE client_traffics SET expiry_time=MAX(expiry_time, ?) WHERE email=?;", (exp, email))
                if total:
                    cur.execute("UPDATE client_traffics SET total=MAX(total, ?) WHERE email=?;", (total, email))
                # enable can be 0/1 - propagate disable safely
                cur.execute("UPDATE client_traffics SET enable=MIN(enable, ?) WHERE email=?;", (enable, email))

                # update agent_state last seen
                agent_state[email] = {"up": up, "down": down}

            cur.execute("COMMIT;")
            # snapshot after update
            snap = get_master_snapshot(cur)
            con.close()

            state[AGENT_ID] = agent_state
            save_state(state)

            sys.stdout.write(json.dumps({"ok": True, "snapshot": snap}, ensure_ascii=False))
            sys.exit(0)

        except Exception as e:
            last_err = e
            msg = str(e).lower()
            try:
                con.close()
            except Exception:
                pass
            if ("locked" in msg or "busy" in msg):
                time.sleep(0.6)
                continue
            raise

    # locked too long
    if ALLOW_RESTART:
        stop_start_if_needed()
        try:
            # one final attempt
            con, cur = db_connect()
            cur.execute("BEGIN;")
            for r in rows:
                email = r["email"]
                up = int(r.get("up",0)); down = int(r.get("down",0))
                exp = int(r.get("expiry_time",0)); total = int(r.get("total",0))
                enable = int(r.get("enable",0))

                prev = agent_state.get(email, {"up": 0, "down": 0})
                du = up - int(prev.get("up",0)); dd = down - int(prev.get("down",0))
                if du < 0: du = 0
                if dd < 0: dd = 0
                if du or dd:
                    cur.execute("UPDATE client_traffics SET up=up+?, down=down+? WHERE email=?;", (du, dd, email))
                if exp:
                    cur.execute("UPDATE client_traffics SET expiry_time=MAX(expiry_time, ?) WHERE email=?;", (exp, email))
                if total:
                    cur.execute("UPDATE client_traffics SET total=MAX(total, ?) WHERE email=?;", (total, email))
                cur.execute("UPDATE client_traffics SET enable=MIN(enable, ?) WHERE email=?;", (enable, email))

                agent_state[email] = {"up": up, "down": down}

            cur.execute("COMMIT;")
            snap = get_master_snapshot(cur)
            con.close()

            state[AGENT_ID] = agent_state
            save_state(state)

            sys.stdout.write(json.dumps({"ok": True, "snapshot": snap, "used_restart": True}, ensure_ascii=False))
            sys.exit(0)
        finally:
            start_back()

    # if restart disabled:
    sys.stdout.write(json.dumps({"ok": False, "error": str(last_err)}, ensure_ascii=False))
PY
"""
    cmd = [
        "ssh",
        "-i", key,
        "-p", str(master["port"]),
        "-o", "BatchMode=yes",
        "-o", "StrictHostKeyChecking=accept-new",
        "-o", "ConnectTimeout=10",
        f"{master['user']}@{master['host']}",
        "bash", "-lc",
        remote
    ]
    env = os.environ.copy()
    env["AGENT_ID"] = agent_id
    env["MASTER_DB"] = master_db
    env["MASTER_SERVICE"] = master_service
    env["ALLOW_RESTART"] = allow_restart

    p = subprocess.run(cmd, input=payload_json, text=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env)
    if p.returncode != 0:
        raise RuntimeError(f"SSH to master failed.\nSTDERR:\n{p.stderr.strip()}")
    data = json.loads(p.stdout or "{}")
    if not data.get("ok"):
        raise RuntimeError(f"Master update failed: {data.get('error','unknown')}")
    return data.get("snapshot", [])

def run_once():
    conf = load_conf()

    rows = local_rows(conf["local"]["db_path"])
    payload = json.dumps(rows, ensure_ascii=False)

    snap = ssh_master(conf, payload)

    result = apply_snapshot_local(
        conf["local"]["db_path"],
        snap,
        stop_start_fallback=conf.get("allow_local_restart_on_lock", True),
        service_name=conf["local"].get("service_name") or ""
    )
    print(f"SYNC_DONE: {result}  items={len(snap)}")

def main():
    if "--once" in sys.argv:
        run_once()
        return
    run_once()

if __name__ == "__main__":
    main()
PY
  chmod +x "$PY"
}

write_systemd_units() {
  local interval_sec="$1"

  cat >"$SERVICE_FILE" <<EOF
[Unit]
Description=Sync x-ui/3x-ui client traffics (agent)
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
ExecStart=/usr/bin/python3 $PY --once
EOF

  cat >"$TIMER_FILE" <<EOF
[Unit]
Description=Run xui-sync-agent every ${interval_sec}s

[Timer]
OnBootSec=90
OnUnitActiveSec=${interval_sec}
Persistent=true

[Install]
WantedBy=timers.target
EOF

  systemctl daemon-reload
  systemctl enable --now "${SERVICE_NAME}.timer" >/dev/null
}

ensure_key() {
  mkdir -p "$ETC_DIR"
  if [[ ! -f "$KEY" ]]; then
    info "Generating SSH key for agent..."
    ssh-keygen -t ed25519 -f "$KEY" -N '' -C "xui-sync-agent" >/dev/null
    ok "Key generated: $KEY"
  fi
  chmod 600 "$KEY"
}

test_ssh() {
  local user="$1" host="$2" port="$3"
  ssh -i "$KEY" -p "$port" -o BatchMode=yes -o StrictHostKeyChecking=accept-new -o ConnectTimeout=10 \
    "${user}@${host}" "echo OK" >/dev/null 2>&1
}

setup_ssh_access() {
  local user="$1" host="$2" port="$3"
  if test_ssh "$user" "$host" "$port"; then
    ok "SSH access to master works (key-based)."
    return 0
  fi

  warn "SSH key-based access به مستر هنوز آماده نیست."
  echo "می‌خوای کلید این سرور رو روی مستر اضافه کنم؟ (ssh-copy-id) [Y/n]"
  read -r ans
  ans="${ans:-Y}"
  if [[ "$ans" =~ ^[Yy]$ ]]; then
    ssh-copy-id -i "${KEY}.pub" -p "$port" "${user}@${host}"
    ok "Key installed on master."
  else
    warn "بدون key-based SSH، تایمر خودکار کار نمی‌کند."
    warn "خودت کلید ${KEY}.pub را به ~/.ssh/authorized_keys روی مستر اضافه کن."
  fi
}

read_or_default() {
  local prompt="$1" def="$2"
  local val
  read -r -p "$prompt [$def]: " val
  echo "${val:-$def}"
}

write_config() {
  local master_host="$1" master_port="$2" master_user="$3"
  local interval_sec="$4"
  local local_db="$5"
  local local_service="$6"

  local agent_id
  agent_id="$(hostname || echo agent)"

  mkdir -p "$ETC_DIR" "$VAR_DIR"

  # Allow advanced overrides later by editing config.json:
  # master.db_path , master.service_name , allow_master_restart_on_lock
  cat >"$CONF" <<EOF
{
  "agent_id": "$agent_id",
  "ssh_key": "$KEY",
  "allow_local_restart_on_lock": true,
  "allow_master_restart_on_lock": true,
  "master": {
    "host": "$master_host",
    "port": $master_port,
    "user": "$master_user",
    "db_path": "/etc/x-ui/x-ui.db",
    "service_name": "x-ui"
  },
  "local": {
    "db_path": "$local_db",
    "service_name": "$local_service"
  },
  "timer_interval_sec": $interval_sec
}
EOF
  ok "Config written to $CONF"
}

run_sync_now() {
  info "Running sync now..."
  /usr/bin/python3 "$PY" --once
  ok "Sync completed."
}

show_status() {
  echo
  echo "=== Config ==="
  [[ -f "$CONF" ]] && cat "$CONF" || echo "No config yet."
  echo
  echo "=== Systemd timer status ==="
  systemctl status "${SERVICE_NAME}.timer" --no-pager || true
  echo
  systemctl list-timers --no-pager | grep -E "${SERVICE_NAME}|NEXT" || true
  echo
}

main_menu() {
  echo
  echo "============================="
  echo " xui-sync-agent setup (Ubuntu)"
  echo "============================="
  echo "این ابزار را هر بار اجرا کنی می‌تونی interval رو عوض کنی یا همین الان sync کنی."
  echo
}

main() {
  need_root
  install_deps
  write_python_agent
  ensure_key

  main_menu

  local existing_master_host=""; local existing_master_port="22"; local existing_master_user="root"; local existing_interval="3600"
  local existing_local_db=""; local existing_local_service=""

  if [[ -f "$CONF" ]]; then
    existing_master_host="$(python3 -c 'import json;print(json.load(open("'"$CONF"'"))["master"]["host"])' 2>/dev/null || true)"
    existing_master_port="$(python3 -c 'import json;print(json.load(open("'"$CONF"'"))["master"]["port"])' 2>/dev/null || echo 22)"
    existing_master_user="$(python3 -c 'import json;print(json.load(open("'"$CONF"'"))["master"]["user"])' 2>/dev/null || echo root)"
    existing_interval="$(python3 -c 'import json;print(json.load(open("'"$CONF"'")).get("timer_interval_sec",3600))' 2>/dev/null || echo 3600)"
    existing_local_db="$(python3 -c 'import json;print(json.load(open("'"$CONF"'"))["local"]["db_path"])' 2>/dev/null || true)"
    existing_local_service="$(python3 -c 'import json;print(json.load(open("'"$CONF"'"))["local"].get("service_name",""))' 2>/dev/null || true)"
    info "Config found. Press Enter to keep current values."
  fi

  local master_host master_port master_user
  master_host="$(read_or_default "Master IP/Host" "${existing_master_host:-}" )"
  while [[ -z "$master_host" ]]; do
    master_host="$(read_or_default "Master IP/Host" "127.0.0.1")"
  done

  master_port="$(read_or_default "Master SSH port" "${existing_master_port:-22}")"
  master_user="$(read_or_default "Master SSH user" "${existing_master_user:-root}")"

  # local db path
  local local_db local_service
  local_db="$(detect_local_db || true)"
  if [[ -z "$local_db" ]]; then
    warn "Local x-ui DB پیدا نشد. مسیر DB را وارد کن."
    local_db="$(read_or_default "Local DB path" "${existing_local_db:-/etc/x-ui/x-ui.db}")"
  else
    local_db="$(read_or_default "Local DB path" "${existing_local_db:-$local_db}")"
  fi

  local_service="$(detect_local_service || true)"
  if [[ -z "$local_service" ]]; then
    warn "نام سرویس x-ui پیدا نشد. اگر خالی بذاری، فقط retry می‌کنیم و stop/start انجام نمی‌شه."
    local_service="$(read_or_default "Local service name (optional)" "${existing_local_service:-}")"
  else
    local_service="$(read_or_default "Local service name" "${existing_local_service:-$local_service}")"
  fi

  # interval
  local interval_min interval_sec
  local cur_min=$(( existing_interval / 60 ))
  interval_min="$(read_or_default "Update interval (minutes)" "${cur_min:-60}")"
  if ! [[ "$interval_min" =~ ^[0-9]+$ ]]; then interval_min=60; fi
  if (( interval_min < 1 )); then interval_min=1; fi
  interval_sec=$(( interval_min * 60 ))

  write_config "$master_host" "$master_port" "$master_user" "$interval_sec" "$local_db" "$local_service"
  setup_ssh_access "$master_user" "$master_host" "$master_port"
  write_systemd_units "$interval_sec"

  ok "Installed systemd timer: ${SERVICE_NAME}.timer (every ${interval_min} min)"

  echo
  read -r -p "می‌خوای همین الان Sync انجام بشه؟ [y/N]: " do_now
  if [[ "${do_now:-N}" =~ ^[Yy]$ ]]; then
    run_sync_now || true
  fi

  show_status
  ok "Done."
}

main "$@"
